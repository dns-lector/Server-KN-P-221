# Функціональні вирази, лямбда
y = 10
lamg1 = None
w = 90

def init_lamg1() :
    global lamg1
    w = 30
    lamg1 = lambda x : print("x=%d, y=%d, w=%d" % (x, y, w))
    # ілюстрація різних областей: х - належить до параметричної області, у - до глобальної, 
    # w - до області, що руйнується, тобто не буде доступною після оголошення лямбди.
    # Після випробування бачимо, що значення w виводиться 30
    w = 50
    # Додавання цієї інструкції видає 50, тобто складається враження, що утворюється посилання
    # на локальну змінну функціїї
    # Захват (capture) - перенесення (копіювання) до локальної области (лексикографічного околу)
    # лямбди змінних, які належать 
    # зовнішній області, яка буде зруйнована після оголошення лямбди

def exec_lam( lam ) :
    lam()


def main() :
    exec_lam(lambda: print("for exec"))  # передача лямбди як параметра функції
    lam1 = lambda x : print(x)   # lam1 = (x) => print(x)
    lam1('Hello')
    lam2 = lambda x, y : print(x, y)
    lam2(10, 20)
    lam3 = lambda : print("No params")
    lam3()
    (lambda: print("IIFE"))()  # immediately invoked func expression - 
                               # функції миттєвого виклику - не залишаються у пам'яті 
                               # після виконання. 
    init_lamg1()
    lamg1(40)
    global y
    y = 60
    lamg1(1)
    # print(w)  NameError: name 'w' is not defined
    w = 80
    lamg1(2)

if __name__ == "__main__" : main()

'''
Д.З. Реалізувати аналог патерна "Стратегія" засобами лямбд:
Оголосити декілька лямбд, для прикладу можна взяти різні алгоритми
розрахунку середнього значення (арифметичне, геометричне, гармонійне, ...),
представити їх кортежем.
Оголосити кортеж даних, можна випадковий або послідовний.
Визначити які результати дає кожен з методів та вибрати той, що має
максимальне значення - за допомогою окремої функції, яка приймає 
два кортежі - дані та методи (лямбди)
'''